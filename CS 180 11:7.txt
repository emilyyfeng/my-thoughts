Event handling: events connect the user to your program (keystrokes mouse actions, etc)
Event listeners: method in your code that is linked to a widget, processes events generated by that widget, runs on the EDT (has to be "quick" or will slow EDT and make it unresponsive, or has to send work to a different thread)

Event dispatch thread:
- most Swing object methods are not thread safe (aka cannot be safely invoked from multiple threads)
- Swing event handling code and Swing methods runs on the EDT (make sure Swing methods run there!)
- Thread interference & memory consistency errors —  methods that don't run on EDY are subject to unpredictable errors that are difficult to reproduce

LISTENERS (ActionListener — buttons, MouseListener — component entry/exit, MouseMotionListener — component, ItemListener — check boxes, DocumentListener — text fields, KeyListener — text boxes)
ActionListener interface
- must implement:
public void actionPerformed(Action Event e)
- includes... 
	- getSource(): widget (object) generating event
	- getActionCommand(): associated String
	- getWhen(): time of event
- source.setActionCommand(String s) sets the String returned by getActionCommand9)

PushMe
public class PushMe implements ActionListener {
	static JFrame frame;
	
	public static void main(String[] args) { 
		public void raun() { ... }
	}

	public void actionPerformed(ActionEvent e) { ... }
}

Source to listener relationships
- one to one (one event source sends to one listener)
- many to one (many event sources send to one listener, e.g. single piece of code for multiple buttons)
- one to many (one source sends to many listeners — less used, but can allow independent actions on the same button press)

Using ActionListener
- create a named class that implements ActionListener
	- instantiate the object
	- attach it to one or more buttons
- create an instance of a local inner class
	- attach to button(s)
- create an anonymous class
	- always have to attach it

ADAPTER CLASSES
Problem: some interfaces have many methods, may only need to use one of them, & interfaces require implementations for all
Solution: adapter classes that provide default (empty) implementations for all
	- create a subclass, override what you need

e.g. MouseAdapter
- provides default implementations for: mouseEntered(...), mouseClicked(...), mouseExited(...), mousePressed(...), mouseReleased(...)
- only have to override what you use

Layout managers: do 2 things (1. determine the minimum/preferred/maximum sizes for a container, 2. lay out the container's children)
- includes: BorderLayout, BoxLayout, CardLayout, FlowLayout, GridBagLayout, GridLayout, GroupLayout, SpringLayout

(In)valid
- containers can be valid/invalid — isValid() tells us which
- valid containers have all children laid out and valid
- pack() and setVisible() validate components, pack() causes window to be sized to fit the preferred size and layouts of its subcomponents

e.g. FlowLayout
- JFrame defaults to BorderLayout
- everything else defaults to FlowLayout
	- widgets "flow" one after another
	- left to right, then top to bottom
	- each "line" centered
	- widgets left at "preferred" size

e.g. GridLayout
- grid of cells — rows x cols
- all cells are same size
- widgets are placed in cells
- each component takes all available space within its cell
setLayout(new GridLayout(0, 4)); => four columns per row, as many rows as necessary

Factory pattern: a design pattern for creating objects
- uses static method instead of "new"
- e.g. BorderFactory:
BorderFactory.createLineBorder(Color.RED);
BorderFactor.createTitledBorder("Sub Panel");
- returns a suitable (possibly "new") object
- allows re-use of "read-only" (shared) objects

Graphics class
- "knows" how to draw on a given Canvas or component
- coordinates in pixels: upper left is 0,0; X moves right, Y moves down
- graphics context includes: current color, current font, & other properties

Graphics operations:
- call from within paint(), runs on the EDT
- e.g. g.drawLine(x1, y1, x2, y2), g.drawRect(x, y, width, height), g.fillOval(x, y, width, height), g.drawString(s, x, y)
- when model changes, call repaint()
	- repaint() is thread safe — schedules paint() on the EDT for later

Paint
- paint() is part of java.awt.Component
- Javax.swing.JComponent extends Component, paint() becomes:
	- paintComponent(Graphics g)
	- paintBorder(Graphics g)
	- paintChildren(Graphics g)
- usually only want to override paintComponent()
- remember to call super.paintComponent()